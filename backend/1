// contracts/Lending.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

contract DETH is ERC20, Ownable {
    address public minter;

    constructor() ERC20("Deposited Ether", "dETH") Ownable(msg.sender) {}

    function setMinter(address _minter) external onlyOwner {
        require(minter == address(0), "Minter already set");
        require(_minter != address(0), "Invalid minter address");
        minter = _minter;
    }

    function mint(address to, uint256 amount) external {
        require(msg.sender == minter, "Only minter can mint");
        require(to != address(0), "Cannot mint to zero address");
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external {
        require(msg.sender == minter, "Only minter can burn");
        require(from != address(0), "Cannot burn from zero address");
        _burn(from, amount);
    }
}

contract Lending is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    
    DETH public immutable dETHToken;
    uint256 public constant LTV_BPS = 8000; // 80%
    uint256 public constant LIQ_THRESHOLD_BPS = 8500; // 85%
    uint256 public constant LIQ_BONUS_BPS = 10500; // 105% (5% bonus for liquidator)
    uint256 public constant PRECISION = 1e18;
    uint256 private constant PRICE_TIMEOUT = 259200; // 3 days

    mapping(address => bool) public supportedCollateral;
    mapping(address => AggregatorV3Interface) public priceFeed;
    mapping(address => mapping(address => uint256)) public collateralBalance;
    mapping(address => uint256) public borrowBalances;
    
    address[] public collateralList;
    AggregatorV3Interface public immutable ethUsdFeed;

    event DepositedETH(address indexed user, uint256 amount, uint256 dETHMinted);
    event WithdrawnETH(address indexed user, uint256 dETHBurned, uint256 amount);
    event CollateralSupported(address indexed token, address indexed feed, bool isSupported);
    event CollateralDeposited(address indexed user, address indexed token, uint256 amount);
    event CollateralWithdrawn(address indexed user, address indexed token, uint256 amount);
    event Borrowed(address indexed user, uint256 amount);
    event Repaid(address indexed user, uint256 repaid, uint256 remainingDebt);
    event Liquidated(address indexed liquidator, address indexed user, uint256 repaid, uint256 collateralSeized);

    constructor(address _dETH, address _ethUsdFeed) Ownable(msg.sender) {
        require(_dETH != address(0), "Invalid dETH address");
        require(_ethUsdFeed != address(0), "Invalid ETH USD feed address");
        dETHToken = DETH(_dETH);
        ethUsdFeed = AggregatorV3Interface(_ethUsdFeed);
    }

    function setSupportedCollateral(address token, bool supported, address tokenUsdFeed) external onlyOwner {
        require(token != address(0), "Invalid token address");
        if (supported) {
            require(tokenUsdFeed != address(0), "Invalid price feed address");
            if (!supportedCollateral[token]) {
                collateralList.push(token);
            }
            supportedCollateral[token] = true;
            priceFeed[token] = AggregatorV3Interface(tokenUsdFeed);
        } else {
            supportedCollateral[token] = false;
            priceFeed[token] = AggregatorV3Interface(address(0));
        }
        emit CollateralSupported(token, tokenUsdFeed, supported);
    }

    function depositInPool() external payable nonReentrant {
        require(msg.value > 0, "Must send ETH");
        uint256 totalSupply = dETHToken.totalSupply();
        uint256 poolBefore = address(this).balance - msg.value;
        uint256 mintAmount = (totalSupply == 0 || poolBefore == 0) ? msg.value : (msg.value * totalSupply) / poolBefore;
        
        dETHToken.mint(msg.sender, mintAmount);
        emit DepositedETH(msg.sender, msg.value, mintAmount);
    }

    function withdrawFromPool(uint256 dETHAmount) external nonReentrant {
        require(dETHAmount > 0, "Amount must be greater than 0");
        require(dETHToken.balanceOf(msg.sender) >= dETHAmount, "Insufficient dETH balance");
        
        uint totalSupply = dETHToken.totalSupply();
        require(totalSupply > 0, "Empty pool");
        
        uint256 poolETH = address(this).balance;
        uint256 ethOut = (dETHAmount * poolETH) / totalSupply;
        require(ethOut > 0, "No ETH to withdraw");
        
        dETHToken.burn(msg.sender, dETHAmount);
        _safeTransferETH(msg.sender, ethOut);
        emit WithdrawnETH(msg.sender, dETHAmount, ethOut);
    }

    function depositCollateral(address token, uint256 amount) external nonReentrant {
        require(supportedCollateral[token], "Collateral not supported");
        require(amount > 0, "Amount must be greater than 0");
        
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        collateralBalance[msg.sender][token] += amount;
        emit CollateralDeposited(msg.sender, token, amount);
    }

    function withdrawCollateral(address token, uint256 amount) external nonReentrant {
        require(supportedCollateral[token], "Collateral not supported");
        require(amount > 0, "Amount must be greater than 0");
        require(collateralBalance[msg.sender][token] >= amount, "Insufficient collateral balance");

        if (borrowBalances[msg.sender] > 0) {
            collateralBalance[msg.sender][token] -= amount;
            require(getHealthFactor(msg.sender) >= PRECISION, "Withdrawal would make position unhealthy");
            collateralBalance[msg.sender][token] += amount;
        }
        
        collateralBalance[msg.sender][token] -= amount;
        IERC20(token).safeTransfer(msg.sender, amount);
        emit CollateralWithdrawn(msg.sender, token, amount);
    }

    function borrow(uint256 amountWei) external nonReentrant {
        require(amountWei > 0, "Amount must be greater than 0");
        require(address(this).balance >= amountWei, "Insufficient pool balance");
        
        uint256 collateralValueETH = _userCollateralValueInETH(msg.sender);
        require(collateralValueETH > 0, "No collateral deposited");
        
        uint256 maxBorrow = (collateralValueETH * LTV_BPS) / 10000;
        uint256 newTotalDebt = borrowBalances[msg.sender] + amountWei;
        
        require(newTotalDebt <= maxBorrow, "Exceeds borrowing capacity");
        
        borrowBalances[msg.sender] = newTotalDebt;
        _safeTransferETH(msg.sender, amountWei);
        emit Borrowed(msg.sender, amountWei);
    }

    function repay() external payable nonReentrant {
        require(msg.value > 0, "Must send ETH");
        uint256 debt = borrowBalances[msg.sender];
        require(debt > 0, "No debt to repay");
        
        uint256 toApply = msg.value > debt ? debt : msg.value;
        borrowBalances[msg.sender] = debt - toApply;

        if (msg.value > toApply) {
            _safeTransferETH(msg.sender, msg.value - toApply);
        }
        emit Repaid(msg.sender, toApply, borrowBalances[msg.sender]);
    }
    
    function liquidate(address user) external payable nonReentrant {
        require(user != msg.sender, "Cannot liquidate yourself");
        uint256 debt = borrowBalances[user];
        require(debt > 0, "User has no debt");
        require(getHealthFactor(user) < PRECISION, "Position is healthy");
        require(msg.value >= debt, "Insufficient payment for liquidation");

        borrowBalances[user] = 0;
        if (msg.value > debt) {
            _safeTransferETH(msg.sender, msg.value - debt);
        }

        uint256 collateralNeededInEth = (debt * LIQ_BONUS_BPS) / 10000;
        uint256 totalSeizedValueInEth = 0;

        for (uint256 i = 0; i < collateralList.length; i++) {
            address token = collateralList[i];
            uint256 userTokenBalance = collateralBalance[user][token];
            if (userTokenBalance == 0) continue;

            uint256 tokenValueInEth = _tokenValueInETH(token, userTokenBalance);
            uint256 amountToSeize = 0;
            
            if (totalSeizedValueInEth + tokenValueInEth <= collateralNeededInEth) {
                amountToSeize = userTokenBalance;
                totalSeizedValueInEth += tokenValueInEth;
            } else {
                uint256 remainingNeededInEth = collateralNeededInEth - totalSeizedValueInEth;
                amountToSeize = _tokenAmountFromETH(token, remainingNeededInEth);
                totalSeizedValueInEth = collateralNeededInEth;
            }

            collateralBalance[user][token] -= amountToSeize;
            IERC20(token).safeTransfer(msg.sender, amountToSeize);
            
            if (totalSeizedValueInEth >= collateralNeededInEth) break;
        }
        
        emit Liquidated(msg.sender, user, debt, totalSeizedValueInEth);
    }

    // --- VIEW AND HELPER FUNCTIONS ---

    function getHealthFactor(address user) public view returns (uint256) {
        uint256 debt = borrowBalances[user];
        if (debt == 0) return type(uint256).max;

        uint256 collateralETH = _userCollateralValueInETH(user);
        if (collateralETH == 0) return 0;

        uint256 adjustedCollateral = (collateralETH * LIQ_THRESHOLD_BPS) / 10000;
        return (adjustedCollateral * PRECISION) / debt;
    }

    function _userCollateralValueInETH(address user) internal view returns (uint256 totalETH) {
        for (uint256 i = 0; i < collateralList.length; i++) {
            address token = collateralList[i];
            uint256 amount = collateralBalance[user][token];
            if (amount > 0) {
                totalETH += _tokenValueInETH(token, amount);
            }
        }
    }

    function _tokenValueInETH(address token, uint256 amount) internal view returns (uint256) {
        AggregatorV3Interface tokenFeed = priceFeed[token];
        require(address(tokenFeed) != address(0), "No price feed for token");

        ( , int256 tokenUsd, , uint256 updatedAt, ) = tokenFeed.latestRoundData();
        require(tokenUsd > 0, "Invalid token price");
        require(block.timestamp - updatedAt <= PRICE_TIMEOUT, "Price data too old");
        
        ( , int256 ethUsd, , uint256 ethUpdatedAt, ) = ethUsdFeed.latestRoundData();
        require(ethUsd > 0, "Invalid ETH price");
        require(block.timestamp - ethUpdatedAt <= PRICE_TIMEOUT, "ETH price data too old");
        
        uint8 tokenUsdDecimals = tokenFeed.decimals();
        uint8 ethUsdDecimals = ethUsdFeed.decimals();
        uint256 tokenUsdScaled = uint256(tokenUsd) * (10 ** (18 - tokenUsdDecimals));
        uint256 ethUsdScaled = uint256(ethUsd) * (10 ** (18 - ethUsdDecimals));
        
        uint8 tokenDecimals = IERC20Metadata(token).decimals();
        uint256 amountScaled = amount * (10 ** (18 - tokenDecimals));
        
        return (amountScaled * tokenUsdScaled) / ethUsdScaled;
    }
    
    function _tokenAmountFromETH(address token, uint256 ethAmount) internal view returns (uint256) {
        AggregatorV3Interface tokenFeed = priceFeed[token];
        ( , int256 tokenUsd, , , ) = tokenFeed.latestRoundData();
        ( , int256 ethUsd, , , ) = ethUsdFeed.latestRoundData();
        
        uint8 tokenUsdDecimals = tokenFeed.decimals();
        uint8 ethUsdDecimals = ethUsdFeed.decimals();
        uint256 tokenUsdScaled = uint256(tokenUsd) * (10 ** (18 - tokenUsdDecimals));
        uint256 ethUsdScaled = uint256(ethUsd) * (10 ** (18 - ethUsdDecimals));
        
        uint8 tokenDecimals = IERC20Metadata(token).decimals();
        uint256 ethAmountScaled = ethAmount;
        
        uint256 tokenAmountScaled = (ethAmountScaled * ethUsdScaled) / tokenUsdScaled;
        return tokenAmountScaled / (10 ** (18 - tokenDecimals));
    }

    function _safeTransferETH(address to, uint256 amount) internal {
        require(to != address(0), "Cannot transfer to zero address");
        (bool success, ) = to.call{value: amount}("");
        require(success, "ETH transfer failed");
    }

    // --- OTHER VIEW FUNCTIONS ---
    function getUserCollateralValueETH(address user) external view returns (uint256) { return _userCollateralValueInETH(user); }
    function getUserBorrowCapacity(address user) external view returns (uint256) { return (_userCollateralValueInETH(user) * LTV_BPS) / 10000; }
   
    function getCollateralList() external view returns (address[] memory) { return collateralList; }
    function getUtilizationRate() external view returns (uint256) {
        uint256 totalSupply = dETHToken.totalSupply();
        if (totalSupply == 0) return 0;
        uint256 poolBalance = address(this).balance;
        if (poolBalance >= totalSupply) return 0;
        uint256 borrowed = totalSupply - poolBalance;
        return (borrowed * PRECISION) / totalSupply;
    }
    function getPoolBalance() external view returns (uint256) { return address(this).balance; }
    function getTotalSupply() external view returns (uint256) { return dETHToken.totalSupply(); }
    function getTokenPriceUSD(address token) external view returns (uint256) {
        require(supportedCollateral[token], "Token not supported");
        AggregatorV3Interface tokenFeed = priceFeed[token];
        (, int256 price, , uint256 updatedAt, ) = tokenFeed.latestRoundData();
        require(price > 0, "Invalid price");
        uint8 decimals = tokenFeed.decimals();
        return uint256(price) * (10 ** (18 - decimals));
    }
    function getETHPriceUSD() external view returns (uint256) {
        (, int256 price, , uint256 updatedAt, ) = ethUsdFeed.latestRoundData();
        require(price > 0, "Invalid ETH price");
        require(block.timestamp - updatedAt <= PRICE_TIMEOUT, "ETH price data too old");
        uint8 decimals = ethUsdFeed.decimals();
        return uint256(price) * (10 ** (18 - decimals));
    }
    
    receive() external payable {}
}